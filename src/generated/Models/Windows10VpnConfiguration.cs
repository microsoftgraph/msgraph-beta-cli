// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace ApiSdk.Models
{
    /// <summary>
    /// By providing the configurations in this profile you can instruct the Windows 10 device (desktop or mobile) to connect to desired VPN endpoint. By specifying the authentication method and security types expected by VPN endpoint you can make the VPN connection seamless for end user.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class Windows10VpnConfiguration : global::ApiSdk.Models.WindowsVpnConfiguration, IParsable
    {
        /// <summary>Associated Apps. This collection can contain a maximum of 10000 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::ApiSdk.Models.Windows10AssociatedApps>? AssociatedApps { get; set; }
#nullable restore
#else
        public List<global::ApiSdk.Models.Windows10AssociatedApps> AssociatedApps { get; set; }
#endif
        /// <summary>Windows 10 VPN connection types.</summary>
        public global::ApiSdk.Models.Windows10VpnAuthenticationMethod? AuthenticationMethod { get; set; }
        /// <summary>VPN connection types.</summary>
        public global::ApiSdk.Models.Windows10VpnConnectionType? ConnectionType { get; set; }
        /// <summary>Cryptography Suite security settings for IKEv2 VPN in Windows10 and above</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ApiSdk.Models.CryptographySuite? CryptographySuite { get; set; }
#nullable restore
#else
        public global::ApiSdk.Models.CryptographySuite CryptographySuite { get; set; }
#endif
        /// <summary>DNS rules. This collection can contain a maximum of 1000 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::ApiSdk.Models.VpnDnsRule>? DnsRules { get; set; }
#nullable restore
#else
        public List<global::ApiSdk.Models.VpnDnsRule> DnsRules { get; set; }
#endif
        /// <summary>Specify DNS suffixes to add to the DNS search list to properly route short names.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? DnsSuffixes { get; set; }
#nullable restore
#else
        public List<string> DnsSuffixes { get; set; }
#endif
        /// <summary>Extensible Authentication Protocol (EAP) XML. (UTF8 encoded byte array)</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public byte[]? EapXml { get; set; }
#nullable restore
#else
        public byte[] EapXml { get; set; }
#endif
        /// <summary>Enable Always On mode.</summary>
        public bool? EnableAlwaysOn { get; set; }
        /// <summary>Enable conditional access.</summary>
        public bool? EnableConditionalAccess { get; set; }
        /// <summary>Enable device tunnel.</summary>
        public bool? EnableDeviceTunnel { get; set; }
        /// <summary>Enable IP address registration with internal DNS.</summary>
        public bool? EnableDnsRegistration { get; set; }
        /// <summary>Enable single sign-on (SSO) with alternate certificate.</summary>
        public bool? EnableSingleSignOnWithAlternateCertificate { get; set; }
        /// <summary>Enable split tunneling.</summary>
        public bool? EnableSplitTunneling { get; set; }
        /// <summary>Identity certificate for client authentication when authentication method is certificate.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ApiSdk.Models.WindowsCertificateProfileBase? IdentityCertificate { get; set; }
#nullable restore
#else
        public global::ApiSdk.Models.WindowsCertificateProfileBase IdentityCertificate { get; set; }
#endif
        /// <summary>ID of the Microsoft Tunnel site associated with the VPN profile.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? MicrosoftTunnelSiteId { get; set; }
#nullable restore
#else
        public string MicrosoftTunnelSiteId { get; set; }
#endif
        /// <summary>Only associated Apps can use connection (per-app VPN).</summary>
        public bool? OnlyAssociatedAppsCanUseConnection { get; set; }
        /// <summary>Profile target type. Possible values are: user, device, autoPilotDevice.</summary>
        public global::ApiSdk.Models.Windows10VpnProfileTarget? ProfileTarget { get; set; }
        /// <summary>Proxy Server.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ApiSdk.Models.Windows10VpnProxyServer? ProxyServer { get; set; }
#nullable restore
#else
        public global::ApiSdk.Models.Windows10VpnProxyServer ProxyServer { get; set; }
#endif
        /// <summary>Remember user credentials.</summary>
        public bool? RememberUserCredentials { get; set; }
        /// <summary>Routes (optional for third-party providers). This collection can contain a maximum of 1000 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::ApiSdk.Models.VpnRoute>? Routes { get; set; }
#nullable restore
#else
        public List<global::ApiSdk.Models.VpnRoute> Routes { get; set; }
#endif
        /// <summary>Single sign-on Extended Key Usage (EKU).</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ApiSdk.Models.ExtendedKeyUsage? SingleSignOnEku { get; set; }
#nullable restore
#else
        public global::ApiSdk.Models.ExtendedKeyUsage SingleSignOnEku { get; set; }
#endif
        /// <summary>Single sign-on issuer hash.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? SingleSignOnIssuerHash { get; set; }
#nullable restore
#else
        public string SingleSignOnIssuerHash { get; set; }
#endif
        /// <summary>Traffic rules. This collection can contain a maximum of 1000 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::ApiSdk.Models.VpnTrafficRule>? TrafficRules { get; set; }
#nullable restore
#else
        public List<global::ApiSdk.Models.VpnTrafficRule> TrafficRules { get; set; }
#endif
        /// <summary>Trusted Network Domains</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? TrustedNetworkDomains { get; set; }
#nullable restore
#else
        public List<string> TrustedNetworkDomains { get; set; }
#endif
        /// <summary>Windows Information Protection (WIP) domain to associate with this connection.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? WindowsInformationProtectionDomain { get; set; }
#nullable restore
#else
        public string WindowsInformationProtectionDomain { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::ApiSdk.Models.Windows10VpnConfiguration"/> and sets the default values.
        /// </summary>
        public Windows10VpnConfiguration() : base()
        {
            OdataType = "#microsoft.graph.windows10VpnConfiguration";
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::ApiSdk.Models.Windows10VpnConfiguration"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static new global::ApiSdk.Models.Windows10VpnConfiguration CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::ApiSdk.Models.Windows10VpnConfiguration();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public override IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>(base.GetFieldDeserializers())
            {
                { "associatedApps", n => { AssociatedApps = n.GetCollectionOfObjectValues<global::ApiSdk.Models.Windows10AssociatedApps>(global::ApiSdk.Models.Windows10AssociatedApps.CreateFromDiscriminatorValue)?.AsList(); } },
                { "authenticationMethod", n => { AuthenticationMethod = n.GetEnumValue<global::ApiSdk.Models.Windows10VpnAuthenticationMethod>(); } },
                { "connectionType", n => { ConnectionType = n.GetEnumValue<global::ApiSdk.Models.Windows10VpnConnectionType>(); } },
                { "cryptographySuite", n => { CryptographySuite = n.GetObjectValue<global::ApiSdk.Models.CryptographySuite>(global::ApiSdk.Models.CryptographySuite.CreateFromDiscriminatorValue); } },
                { "dnsRules", n => { DnsRules = n.GetCollectionOfObjectValues<global::ApiSdk.Models.VpnDnsRule>(global::ApiSdk.Models.VpnDnsRule.CreateFromDiscriminatorValue)?.AsList(); } },
                { "dnsSuffixes", n => { DnsSuffixes = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "eapXml", n => { EapXml = n.GetByteArrayValue(); } },
                { "enableAlwaysOn", n => { EnableAlwaysOn = n.GetBoolValue(); } },
                { "enableConditionalAccess", n => { EnableConditionalAccess = n.GetBoolValue(); } },
                { "enableDeviceTunnel", n => { EnableDeviceTunnel = n.GetBoolValue(); } },
                { "enableDnsRegistration", n => { EnableDnsRegistration = n.GetBoolValue(); } },
                { "enableSingleSignOnWithAlternateCertificate", n => { EnableSingleSignOnWithAlternateCertificate = n.GetBoolValue(); } },
                { "enableSplitTunneling", n => { EnableSplitTunneling = n.GetBoolValue(); } },
                { "identityCertificate", n => { IdentityCertificate = n.GetObjectValue<global::ApiSdk.Models.WindowsCertificateProfileBase>(global::ApiSdk.Models.WindowsCertificateProfileBase.CreateFromDiscriminatorValue); } },
                { "microsoftTunnelSiteId", n => { MicrosoftTunnelSiteId = n.GetStringValue(); } },
                { "onlyAssociatedAppsCanUseConnection", n => { OnlyAssociatedAppsCanUseConnection = n.GetBoolValue(); } },
                { "profileTarget", n => { ProfileTarget = n.GetEnumValue<global::ApiSdk.Models.Windows10VpnProfileTarget>(); } },
                { "proxyServer", n => { ProxyServer = n.GetObjectValue<global::ApiSdk.Models.Windows10VpnProxyServer>(global::ApiSdk.Models.Windows10VpnProxyServer.CreateFromDiscriminatorValue); } },
                { "rememberUserCredentials", n => { RememberUserCredentials = n.GetBoolValue(); } },
                { "routes", n => { Routes = n.GetCollectionOfObjectValues<global::ApiSdk.Models.VpnRoute>(global::ApiSdk.Models.VpnRoute.CreateFromDiscriminatorValue)?.AsList(); } },
                { "singleSignOnEku", n => { SingleSignOnEku = n.GetObjectValue<global::ApiSdk.Models.ExtendedKeyUsage>(global::ApiSdk.Models.ExtendedKeyUsage.CreateFromDiscriminatorValue); } },
                { "singleSignOnIssuerHash", n => { SingleSignOnIssuerHash = n.GetStringValue(); } },
                { "trafficRules", n => { TrafficRules = n.GetCollectionOfObjectValues<global::ApiSdk.Models.VpnTrafficRule>(global::ApiSdk.Models.VpnTrafficRule.CreateFromDiscriminatorValue)?.AsList(); } },
                { "trustedNetworkDomains", n => { TrustedNetworkDomains = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "windowsInformationProtectionDomain", n => { WindowsInformationProtectionDomain = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public override void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            base.Serialize(writer);
            writer.WriteCollectionOfObjectValues<global::ApiSdk.Models.Windows10AssociatedApps>("associatedApps", AssociatedApps);
            writer.WriteEnumValue<global::ApiSdk.Models.Windows10VpnAuthenticationMethod>("authenticationMethod", AuthenticationMethod);
            writer.WriteEnumValue<global::ApiSdk.Models.Windows10VpnConnectionType>("connectionType", ConnectionType);
            writer.WriteObjectValue<global::ApiSdk.Models.CryptographySuite>("cryptographySuite", CryptographySuite);
            writer.WriteCollectionOfObjectValues<global::ApiSdk.Models.VpnDnsRule>("dnsRules", DnsRules);
            writer.WriteCollectionOfPrimitiveValues<string>("dnsSuffixes", DnsSuffixes);
            writer.WriteByteArrayValue("eapXml", EapXml);
            writer.WriteBoolValue("enableAlwaysOn", EnableAlwaysOn);
            writer.WriteBoolValue("enableConditionalAccess", EnableConditionalAccess);
            writer.WriteBoolValue("enableDeviceTunnel", EnableDeviceTunnel);
            writer.WriteBoolValue("enableDnsRegistration", EnableDnsRegistration);
            writer.WriteBoolValue("enableSingleSignOnWithAlternateCertificate", EnableSingleSignOnWithAlternateCertificate);
            writer.WriteBoolValue("enableSplitTunneling", EnableSplitTunneling);
            writer.WriteObjectValue<global::ApiSdk.Models.WindowsCertificateProfileBase>("identityCertificate", IdentityCertificate);
            writer.WriteStringValue("microsoftTunnelSiteId", MicrosoftTunnelSiteId);
            writer.WriteBoolValue("onlyAssociatedAppsCanUseConnection", OnlyAssociatedAppsCanUseConnection);
            writer.WriteEnumValue<global::ApiSdk.Models.Windows10VpnProfileTarget>("profileTarget", ProfileTarget);
            writer.WriteObjectValue<global::ApiSdk.Models.Windows10VpnProxyServer>("proxyServer", ProxyServer);
            writer.WriteBoolValue("rememberUserCredentials", RememberUserCredentials);
            writer.WriteCollectionOfObjectValues<global::ApiSdk.Models.VpnRoute>("routes", Routes);
            writer.WriteObjectValue<global::ApiSdk.Models.ExtendedKeyUsage>("singleSignOnEku", SingleSignOnEku);
            writer.WriteStringValue("singleSignOnIssuerHash", SingleSignOnIssuerHash);
            writer.WriteCollectionOfObjectValues<global::ApiSdk.Models.VpnTrafficRule>("trafficRules", TrafficRules);
            writer.WriteCollectionOfPrimitiveValues<string>("trustedNetworkDomains", TrustedNetworkDomains);
            writer.WriteStringValue("windowsInformationProtectionDomain", WindowsInformationProtectionDomain);
        }
    }
}
#pragma warning restore CS0618
