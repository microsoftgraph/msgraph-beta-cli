// <auto-generated/>
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System;
namespace ApiSdk.Models
{
    /// <summary>
    /// By providing the configurations in this profile you can instruct the Windows 10 device (desktop or mobile) to connect to desired VPN endpoint. By specifying the authentication method and security types expected by VPN endpoint you can make the VPN connection seamless for end user.
    /// </summary>
    public class Windows10VpnConfiguration : WindowsVpnConfiguration, IParsable
    {
        /// <summary>Associated Apps. This collection can contain a maximum of 10000 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<Windows10AssociatedApps>? AssociatedApps { get; set; }
#nullable restore
#else
        public List<Windows10AssociatedApps> AssociatedApps { get; set; }
#endif
        /// <summary>Windows 10 VPN connection types.</summary>
        public Windows10VpnAuthenticationMethod? AuthenticationMethod { get; set; }
        /// <summary>VPN connection types.</summary>
        public Windows10VpnConnectionType? ConnectionType { get; set; }
        /// <summary>Cryptography Suite security settings for IKEv2 VPN in Windows10 and above</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public ApiSdk.Models.CryptographySuite? CryptographySuite { get; set; }
#nullable restore
#else
        public ApiSdk.Models.CryptographySuite CryptographySuite { get; set; }
#endif
        /// <summary>DNS rules. This collection can contain a maximum of 1000 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<VpnDnsRule>? DnsRules { get; set; }
#nullable restore
#else
        public List<VpnDnsRule> DnsRules { get; set; }
#endif
        /// <summary>Specify DNS suffixes to add to the DNS search list to properly route short names.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? DnsSuffixes { get; set; }
#nullable restore
#else
        public List<string> DnsSuffixes { get; set; }
#endif
        /// <summary>Extensible Authentication Protocol (EAP) XML. (UTF8 encoded byte array)</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public byte[]? EapXml { get; set; }
#nullable restore
#else
        public byte[] EapXml { get; set; }
#endif
        /// <summary>Enable Always On mode.</summary>
        public bool? EnableAlwaysOn { get; set; }
        /// <summary>Enable conditional access.</summary>
        public bool? EnableConditionalAccess { get; set; }
        /// <summary>Enable device tunnel.</summary>
        public bool? EnableDeviceTunnel { get; set; }
        /// <summary>Enable IP address registration with internal DNS.</summary>
        public bool? EnableDnsRegistration { get; set; }
        /// <summary>Enable single sign-on (SSO) with alternate certificate.</summary>
        public bool? EnableSingleSignOnWithAlternateCertificate { get; set; }
        /// <summary>Enable split tunneling.</summary>
        public bool? EnableSplitTunneling { get; set; }
        /// <summary>Identity certificate for client authentication when authentication method is certificate.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public WindowsCertificateProfileBase? IdentityCertificate { get; set; }
#nullable restore
#else
        public WindowsCertificateProfileBase IdentityCertificate { get; set; }
#endif
        /// <summary>ID of the Microsoft Tunnel site associated with the VPN profile.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? MicrosoftTunnelSiteId { get; set; }
#nullable restore
#else
        public string MicrosoftTunnelSiteId { get; set; }
#endif
        /// <summary>Only associated Apps can use connection (per-app VPN).</summary>
        public bool? OnlyAssociatedAppsCanUseConnection { get; set; }
        /// <summary>Profile target type. Possible values are: user, device, autoPilotDevice.</summary>
        public Windows10VpnProfileTarget? ProfileTarget { get; set; }
        /// <summary>Proxy Server.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public Windows10VpnProxyServer? ProxyServer { get; set; }
#nullable restore
#else
        public Windows10VpnProxyServer ProxyServer { get; set; }
#endif
        /// <summary>Remember user credentials.</summary>
        public bool? RememberUserCredentials { get; set; }
        /// <summary>Routes (optional for third-party providers). This collection can contain a maximum of 1000 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<VpnRoute>? Routes { get; set; }
#nullable restore
#else
        public List<VpnRoute> Routes { get; set; }
#endif
        /// <summary>Single sign-on Extended Key Usage (EKU).</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public ExtendedKeyUsage? SingleSignOnEku { get; set; }
#nullable restore
#else
        public ExtendedKeyUsage SingleSignOnEku { get; set; }
#endif
        /// <summary>Single sign-on issuer hash.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? SingleSignOnIssuerHash { get; set; }
#nullable restore
#else
        public string SingleSignOnIssuerHash { get; set; }
#endif
        /// <summary>Traffic rules. This collection can contain a maximum of 1000 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<VpnTrafficRule>? TrafficRules { get; set; }
#nullable restore
#else
        public List<VpnTrafficRule> TrafficRules { get; set; }
#endif
        /// <summary>Trusted Network Domains</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? TrustedNetworkDomains { get; set; }
#nullable restore
#else
        public List<string> TrustedNetworkDomains { get; set; }
#endif
        /// <summary>Windows Information Protection (WIP) domain to associate with this connection.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? WindowsInformationProtectionDomain { get; set; }
#nullable restore
#else
        public string WindowsInformationProtectionDomain { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="Windows10VpnConfiguration"/> and sets the default values.
        /// </summary>
        public Windows10VpnConfiguration() : base()
        {
            OdataType = "#microsoft.graph.windows10VpnConfiguration";
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="Windows10VpnConfiguration"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static new Windows10VpnConfiguration CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new Windows10VpnConfiguration();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public override IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>(base.GetFieldDeserializers())
            {
                { "associatedApps", n => { AssociatedApps = n.GetCollectionOfObjectValues<Windows10AssociatedApps>(Windows10AssociatedApps.CreateFromDiscriminatorValue)?.ToList(); } },
                { "authenticationMethod", n => { AuthenticationMethod = n.GetEnumValue<Windows10VpnAuthenticationMethod>(); } },
                { "connectionType", n => { ConnectionType = n.GetEnumValue<Windows10VpnConnectionType>(); } },
                { "cryptographySuite", n => { CryptographySuite = n.GetObjectValue<ApiSdk.Models.CryptographySuite>(ApiSdk.Models.CryptographySuite.CreateFromDiscriminatorValue); } },
                { "dnsRules", n => { DnsRules = n.GetCollectionOfObjectValues<VpnDnsRule>(VpnDnsRule.CreateFromDiscriminatorValue)?.ToList(); } },
                { "dnsSuffixes", n => { DnsSuffixes = n.GetCollectionOfPrimitiveValues<string>()?.ToList(); } },
                { "eapXml", n => { EapXml = n.GetByteArrayValue(); } },
                { "enableAlwaysOn", n => { EnableAlwaysOn = n.GetBoolValue(); } },
                { "enableConditionalAccess", n => { EnableConditionalAccess = n.GetBoolValue(); } },
                { "enableDeviceTunnel", n => { EnableDeviceTunnel = n.GetBoolValue(); } },
                { "enableDnsRegistration", n => { EnableDnsRegistration = n.GetBoolValue(); } },
                { "enableSingleSignOnWithAlternateCertificate", n => { EnableSingleSignOnWithAlternateCertificate = n.GetBoolValue(); } },
                { "enableSplitTunneling", n => { EnableSplitTunneling = n.GetBoolValue(); } },
                { "identityCertificate", n => { IdentityCertificate = n.GetObjectValue<WindowsCertificateProfileBase>(WindowsCertificateProfileBase.CreateFromDiscriminatorValue); } },
                { "microsoftTunnelSiteId", n => { MicrosoftTunnelSiteId = n.GetStringValue(); } },
                { "onlyAssociatedAppsCanUseConnection", n => { OnlyAssociatedAppsCanUseConnection = n.GetBoolValue(); } },
                { "profileTarget", n => { ProfileTarget = n.GetEnumValue<Windows10VpnProfileTarget>(); } },
                { "proxyServer", n => { ProxyServer = n.GetObjectValue<Windows10VpnProxyServer>(Windows10VpnProxyServer.CreateFromDiscriminatorValue); } },
                { "rememberUserCredentials", n => { RememberUserCredentials = n.GetBoolValue(); } },
                { "routes", n => { Routes = n.GetCollectionOfObjectValues<VpnRoute>(VpnRoute.CreateFromDiscriminatorValue)?.ToList(); } },
                { "singleSignOnEku", n => { SingleSignOnEku = n.GetObjectValue<ExtendedKeyUsage>(ExtendedKeyUsage.CreateFromDiscriminatorValue); } },
                { "singleSignOnIssuerHash", n => { SingleSignOnIssuerHash = n.GetStringValue(); } },
                { "trafficRules", n => { TrafficRules = n.GetCollectionOfObjectValues<VpnTrafficRule>(VpnTrafficRule.CreateFromDiscriminatorValue)?.ToList(); } },
                { "trustedNetworkDomains", n => { TrustedNetworkDomains = n.GetCollectionOfPrimitiveValues<string>()?.ToList(); } },
                { "windowsInformationProtectionDomain", n => { WindowsInformationProtectionDomain = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public override void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            base.Serialize(writer);
            writer.WriteCollectionOfObjectValues<Windows10AssociatedApps>("associatedApps", AssociatedApps);
            writer.WriteEnumValue<Windows10VpnAuthenticationMethod>("authenticationMethod", AuthenticationMethod);
            writer.WriteEnumValue<Windows10VpnConnectionType>("connectionType", ConnectionType);
            writer.WriteObjectValue<ApiSdk.Models.CryptographySuite>("cryptographySuite", CryptographySuite);
            writer.WriteCollectionOfObjectValues<VpnDnsRule>("dnsRules", DnsRules);
            writer.WriteCollectionOfPrimitiveValues<string>("dnsSuffixes", DnsSuffixes);
            writer.WriteByteArrayValue("eapXml", EapXml);
            writer.WriteBoolValue("enableAlwaysOn", EnableAlwaysOn);
            writer.WriteBoolValue("enableConditionalAccess", EnableConditionalAccess);
            writer.WriteBoolValue("enableDeviceTunnel", EnableDeviceTunnel);
            writer.WriteBoolValue("enableDnsRegistration", EnableDnsRegistration);
            writer.WriteBoolValue("enableSingleSignOnWithAlternateCertificate", EnableSingleSignOnWithAlternateCertificate);
            writer.WriteBoolValue("enableSplitTunneling", EnableSplitTunneling);
            writer.WriteObjectValue<WindowsCertificateProfileBase>("identityCertificate", IdentityCertificate);
            writer.WriteStringValue("microsoftTunnelSiteId", MicrosoftTunnelSiteId);
            writer.WriteBoolValue("onlyAssociatedAppsCanUseConnection", OnlyAssociatedAppsCanUseConnection);
            writer.WriteEnumValue<Windows10VpnProfileTarget>("profileTarget", ProfileTarget);
            writer.WriteObjectValue<Windows10VpnProxyServer>("proxyServer", ProxyServer);
            writer.WriteBoolValue("rememberUserCredentials", RememberUserCredentials);
            writer.WriteCollectionOfObjectValues<VpnRoute>("routes", Routes);
            writer.WriteObjectValue<ExtendedKeyUsage>("singleSignOnEku", SingleSignOnEku);
            writer.WriteStringValue("singleSignOnIssuerHash", SingleSignOnIssuerHash);
            writer.WriteCollectionOfObjectValues<VpnTrafficRule>("trafficRules", TrafficRules);
            writer.WriteCollectionOfPrimitiveValues<string>("trustedNetworkDomains", TrustedNetworkDomains);
            writer.WriteStringValue("windowsInformationProtectionDomain", WindowsInformationProtectionDomain);
        }
    }
}
